use serde::{Deserialize, Serialize};
use serde_json::json;

use crate::{
    error::AppError,
    logger,
    structs::{Item, ItemDetails},
    wfm_client::client::WFMClient, helper,
};

// On New Message
// @WS/chats/NEW_MESSAGE

// Send Message
// type: "@WS/chats/SEND_MESSAGE",
// payload: {
//     chat_id: e,
//     message: t,
//     temp_id: o
// }
pub struct ChatModule<'a> {
    pub client: &'a WFMClient,
}

impl<'a> ChatModule<'a> {
    pub async fn get_chats(&self) -> Result<Vec<ChatData>, AppError> {
        match self.client.get("im/chats", Some("chats")).await {
            Ok((chats, _headers)) => {
                Ok(chats)
            }
            Err(e) => Err(e),
        }
    }

    pub async fn get_chat(&self, id: String) -> Result<Vec<ChatMessage>, AppError> {
        let url = format!("im/chats/{}", id);
        match self.client.get(&url, Some("messages")).await {
            Ok((chat, _headers)) => {
                logger::info(
                    "ChatModule",
                    format!("For Chat: {:?}", id).as_str(),
                    true,
                    Some(self.client.log_file.as_str()),
                );
                Ok(chat)
            }
            Err(e) => Err(e),
        }
    }

    pub async fn delete(&self, id: String) -> Result<String, AppError> {
        let url = format!("im/chats/{}", id);
        match self.client.get(&url, Some("chat_id")).await {
            Ok((chat, _headers)) => {
                logger::info(
                    "ChatModule",
                    format!("Deleted Chat: {:?}", id).as_str(),
                    true,
                    Some(self.client.log_file.as_str()),
                );
                self.emit("DELETE", json!({ "id": id }));
                Ok(chat)
            }
            Err(e) => Err(e),
        }
    }
    pub fn emit(&self, operation: &str, data: serde_json::Value) {
        helper::emit_update("ChatMessages", operation, Some(data));
    }
}
/// Generated by https://quicktype.io

#[derive(Serialize, Deserialize)]
pub struct ChatData {
    #[serde(rename = "id")]
    id: String,

    #[serde(rename = "chat_with")]
    chat_with: Vec<ChatMessageWith>,

    #[serde(rename = "unread_count")]
    unread_count: i64,

    #[serde(rename = "chat_name")]
    chat_name: String,

    #[serde(rename = "messages")]
    messages: Vec<ChatMessage>,

    #[serde(rename = "last_update")]
    last_update: String,
}

#[derive(Serialize, Deserialize)]
pub struct ChatMessageWith {
    #[serde(rename = "reputation")]
    reputation: i64,

    #[serde(rename = "locale")]
    locale: String,

    #[serde(rename = "avatar")]
    avatar: String,

    #[serde(rename = "last_seen")]
    last_seen: String,

    #[serde(rename = "ingame_name")]
    ingame_name: String,

    #[serde(rename = "status")]
    status: String,

    #[serde(rename = "id")]
    id: String,

    #[serde(rename = "region")]
    region: String,
}

#[derive(Serialize, Deserialize)]
pub struct ChatMessage {
    #[serde(rename = "message")]
    message: String,

    #[serde(rename = "id")]
    id: String,

    #[serde(rename = "chat_id")]
    chat_id: String,

    #[serde(rename = "send_date")]
    send_date: String,

    #[serde(rename = "message_from")]
    message_from: String,

    #[serde(rename = "raw_message")]
    raw_message: String,
}
